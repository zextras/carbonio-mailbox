// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: GPL-2.0-only

package com.zimbra.cs.mailbox.calendar;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.zimbra.common.calendar.ICalTimeZone;
import com.zimbra.common.calendar.ParsedDateTime;
import com.zimbra.common.calendar.ParsedDuration;
import com.zimbra.common.calendar.TimeZoneMap;
import com.zimbra.common.calendar.ZCalendar.ICalTok;
import com.zimbra.common.calendar.ZWeekDay;
import com.zimbra.common.localconfig.DebugConfig;
import com.zimbra.common.service.ServiceException;
import com.zimbra.common.soap.Element;
import com.zimbra.common.soap.MailConstants;
import com.zimbra.common.util.ListUtil;
import com.zimbra.common.util.StringUtil;
import com.zimbra.common.util.ZimbraLog;
import com.zimbra.cs.mailbox.CalendarItem;
import com.zimbra.cs.mailbox.CalendarItem.Instance;
import com.zimbra.cs.mailbox.Metadata;


/**
 * @author tim
 *
 * We use this class to represent a full iCal recurrence -- as such, it is really used in two distinct
 * ways:
 *
 *   As a member of an Invite, this class (well, a tree of this) represents a combination of
 * RRULE, EXRULE, RDATE, EXDATE which all generate instances of the same Invite.  All
 * generated instances point to that same Invite.
 *
 *   As a member of an CalendarItem, this tree represents the overall recurrence-rule for the calendar item.
 * IE there is a "default" Invite which generates a bunch of instances, and then there are Exceptions
 * which each have a RecurrenceId (which corresponds to an instance generated by the default) and which
 * override or cancel that instance.  The instances returned from an CalendarItem's Recurrence tree
 * can point to many Invites.
 *
 */
public class Recurrence
{
    /**
     * RecurrenceRule -- from the default invite.
     *
     * Can have add/subtract sub-parts as well as Exception parts
     */
    public static final int TYPE_RECURRENCE = 1;

    /**
     * ExceptionRule -- an Exception (RecurrenceID != 0) invite
     *
     * Has a RecurId and can also have add/subtract sub-parts
     */
    public static final int TYPE_EXCEPTION = 2;

    /**
     * Cancellation -- An exception with RFC2446 method=CANCEL
     *
     * Has a RecurId.
     */
    public static final int TYPE_CANCELLATION = 3;

    /**
     * Always stored as part of SingleDates
     */
    public static final int TYPE_SINGLE_INSTANCE_DEPRECATED = 4;

    /**
     * Always stored as part of a Recurrence, Exception, or Cancellation -- a rule for generating dates
     *
     * Use the getZRecur() API to access the rule itself
     */
    public static final int TYPE_REPEATING = 5;

    /**
     * Always stored as part of a Recurrence, Exception, or Cancellation --
     * a list of one or more SingleDates.DateValue objects
     */
    public static final int TYPE_SINGLE_DATES = 6;


    /**
     * @author tim
     *
     * Represents a full iCal recurrence ruleset -- including exceptions, etc.
     *
     * The concrete subclasses are:
     *    SingleDates: a list of 1-time events
     *
     *    SimpleRepeatingRule: anything that can be expressed in a single rule...RECUR in the iCal RFC
     *
     *    RecurrenceRule: Rule which fully expresses iCal grammar (support Exceptions, EXRULE, etc)
     *
     *    ExceptionRule: rule that has a RECURRENCE_ID which is used to determine when it applies
     *
     */
    public interface IRecurrence extends Cloneable {
        public Metadata encodeMetadata();

        abstract List<Instance> expandInstances(int calItemId, long start, long end)
        throws ServiceException;

        // get the first time for which the rule has instances
        public ParsedDateTime getStartTime();
        // get the last time (-1 means forever) for which the rule has instances
        public ParsedDateTime getEndTime() throws ServiceException;

        public Object clone();

        /**
         * @return TYPE_RECURRENCE, TYPE_EXCEPTION, TYPE_CANCELLATION, TYPE_SINGLE_DATES, or TYPE_REPEATING
         */
        public int getType();

        /**
         * @return an Iterator over all child rules that add instances to this current node, or NULL if none
         */
        public Iterator /* IRecurrence */ addRulesIterator();

        /**
         * @return an Iterator over all child rules that add instances to this current node, or NULL if none
         */
        public Iterator /* IRecurrence */ subRulesIterator();


        /**
         * @return Identifier for the Invite which created this particular rule
         */
        public InviteInfo getInviteInfo();


        /**
         * WARNING WARNING: this is a special call only used when initializing an INVITE,
         * basically it walks the entire Recurrence chain and sets the InvId to the
         * passed-in value....while this is OK in the case of a single-Invite's recurrence,
         * if this is called on an CalendarItem's Recurrence, it will cause Bad Things To Happen!
         *
         * @param invId
         */
        public void setInviteId(InviteInfo invId);

        abstract public Element toXml(Element parent);
    }


    /**
     * @author tim
     *
     * Superset of IRecurrence for exception rules: they have a RecurId
     *
     * Real implementations are ExceptionRule and CancellationRule
     */
    public static interface IException extends IRecurrence
    {
        public boolean matches(long date);

        public RecurId getRecurId();
    }

    /**
     * @author tim
     *
     * A subnode which generates instances -- ie right now either a SingleDates
     * or SimpleRepeatingRule
     *
     */
    public static interface IInstanceGeneratingRule extends IRecurrence {
        @Override
        public InviteInfo getInviteInfo();
    }


    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////


    public static IRecurrence decodeMetadata(Metadata meta, TimeZoneMap tzmap)
    throws ServiceException {
        try {
            int ruleType = (int) meta.getLong(FN_RULE_TYPE);

            switch (ruleType) {
            case RULE_SIMPLE_REPEATING_RULE:
                return new SimpleRepeatingRule(meta, tzmap);
            case RULE_EXCEPTION_RULE:
                return new ExceptionRule(meta, tzmap);
            case RULE_RECURRENCE_RULE:
                return new RecurrenceRule(meta, tzmap);
            case RULE_SINGLE_DATES:
                SingleDates sdates = new SingleDates(meta, tzmap);
                return sdates.getRdateExdate().isEXDATE() || DebugConfig.enableRdate ? sdates : null;
            }
        } catch (ParseException e) {
            throw ServiceException.FAILURE("Parse excetion on metadata: " + meta, e);
        }
        throw new IllegalArgumentException("Unknown IRecur type: " + meta.get(FN_RULE_TYPE));
    }

    static final String FN_RULE_TYPE = "t";
    static final int RULE_SIMPLE_REPEATING_RULE = 2;
    static final int RULE_EXCEPTION_RULE = 3;
    static final int RULE_RECURRENCE_RULE = 4;
    static final int RULE_SINGLE_INSTANCE_DEPRECATED = 5;
    static final int RULE_SINGLE_DATES = 6;

    /**
     * @author tim
     *
     * Internal Node -- basically just wraps an ArrayList of subrules and does
     * some convienence stuff (e.g. getStartTime calculates the earliest starting time
     * for all the rules we're sorting, etc)
     *
     */
    public static class MultiRuleSorter
    {
        static private final String FN_NUM_RULES = "nr";
        static private final String FN_RULE = "r";

        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_NUM_RULES, mRules.size());
            for (int i = 0; i < mRules.size(); i++)
                meta.put(FN_RULE + i, mRules.get(i).encodeMetadata());
            return meta;
        }

        @Override
        public Object clone() {
            List<IRecurrence> newRules = new ArrayList<IRecurrence>();
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence rule = (IRecurrence) iter.next();
                newRules.add((IRecurrence) rule.clone());
            }
            return new MultiRuleSorter(newRules);
        }

        public Iterator<IRecurrence> iterator() {
            return mRules.iterator();
        }

        public MultiRuleSorter(Metadata meta, TimeZoneMap tzmap) throws ServiceException {
            int numRules = (int) meta.getLong(FN_NUM_RULES);
            mRules = new ArrayList<IRecurrence>(numRules);
            for (int i = 0; i < numRules; i++) {
                try {
                    IRecurrence recurrence = Recurrence.decodeMetadata(meta.getMap(FN_RULE + i), tzmap);
                    if (recurrence != null) {
                        mRules.add(recurrence);
                    }
                } catch(Exception e) {}
            }
        }

        public MultiRuleSorter(List<IRecurrence> rules) {
            assert((rules == null) || (rules.size() == 0) || (rules.get(0) instanceof IInstanceGeneratingRule));
            mRules = rules;
        }

        public void setInviteId(InviteInfo invId) {
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                cur.setInviteId(invId);
            }
        }

        public Element toXml(Element parent) {
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                parent.addElement(cur.toXml(parent));
            }
            return parent;
        }

        List<Instance> expandInstances(int calItemId, long start, long end)
        throws ServiceException {
            List lists[] = new ArrayList[mRules.size()];
            int num = 0;
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                lists[num] = cur.expandInstances(calItemId, start, end);
                num++;
            }

            List<Instance> toRet = new LinkedList<Instance>();
            ListUtil.mergeSortedLists(toRet, lists, true);

            return toRet;
        }

        @Override
        public String toString() {
            StringBuffer toRet = new StringBuffer();
            toRet.append("(");
            for (Iterator iter = mRules.iterator();iter.hasNext();) {
                IRecurrence rule  = (IRecurrence)iter.next();
                toRet.append(rule.toString());
            }
            toRet.append(")");
            return toRet.toString();
        }

        public ParsedDateTime getStartTime() {
            ParsedDateTime earliestStart = null;
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                ParsedDateTime start = cur.getStartTime();
                if (earliestStart == null || (start != null && start.compareTo(earliestStart) < 0)) {
                    earliestStart = start;
                }
            }
            return earliestStart;
        }

        public ParsedDateTime getEndTime() throws ServiceException {
            ParsedDateTime latestEnd = null;
            for (Iterator iter = mRules.iterator(); iter.hasNext();) {
                IRecurrence cur = (IRecurrence)iter.next();
                ParsedDateTime end = cur.getEndTime();
                if (latestEnd == null || (end != null && end.compareTo(latestEnd)>0)) {
                    latestEnd = end;
                }
            }
            return latestEnd;
        }

        private final List<IRecurrence> mRules;

    }

    public static class SingleDates implements IInstanceGeneratingRule {
        private static final String FN_RDATE_EXDATE = "rexd";
        private static final String FN_DEFAULT_DURATION = "defdur";
        private static final String FN_INVID = "inv";

        @Override
        public int getType() { return TYPE_SINGLE_DATES; }

        public RdateExdate getRdateExdate() { return mRdateExdate; }

        @Override
        public Iterator addRulesIterator() { return null; }
        @Override
        public Iterator subRulesIterator() { return null; }

        @Override
        public void setInviteId(InviteInfo invId) {
            mInvId = invId;
        }

        @Override
        public InviteInfo getInviteInfo() {
            return mInvId;
        }

        @Override
        public String toString() {
            StringBuilder toRet = new StringBuilder("[");
            if (mRdateExdate != null) {
                if (mRdateExdate.isRDATE())
                    toRet.append("rdate=[");
                else
                    toRet.append("exdate=[");
                toRet.append(mRdateExdate.toString()).append("]");
            } else {
                toRet.append("rdate/exdate=<none>");
            }
            toRet.append(", defaultDuration=").append(mDefaultDuration.toString());
            if (mInvId != null)
                toRet.append(", InvId=").append(mInvId.toString());
            toRet.append("]");

            return toRet.toString();
        }

        @Override
        public ParsedDateTime getStartTime() {
            ParsedDateTime start = null;
            for (DateValue val : mDates) {
                ParsedDateTime valStart = val.getStartTime();
                if (start == null || start.compareTo(valStart) > 0)
                    start = valStart;
            }
            return start;
        }

        @Override
        public ParsedDateTime getEndTime() {
            ParsedDateTime end = null;
            for (DateValue val : mDates) {
                ParsedDateTime valEnd = val.getEndTime();
                if (end == null || end.compareTo(valEnd) < 0)
                    end = valEnd;
            }
            return end;
        }

        /**
         * @return currently returns ALL instances, even if they are outside the requested range
         */
        @Override
        public List<Instance> expandInstances(int calItemId, long start, long end) {
            return expandInstances(calItemId);
        }

        /**
         * @return returns ALL instances - know this will not be an infinite list...
         */
        public List<Instance> expandInstances(int calItemId) {
            List<Instance> list = new ArrayList<Instance>();
            if (mRdateExdate.isEXDATE() || DebugConfig.enableRdate) {
                for (DateValue val : mDates) {
                    ParsedDateTime valStart = val.getStartTime();
                    ParsedDateTime valEnd = val.getEndTime();
                    boolean allDay = !valStart.hasTime() ||
                            (valStart.hasZeroTime() && mDefaultDuration != null && mDefaultDuration.isMultipleOfDays());
                    list.add(new Instance(calItemId, mInvId, true, true,
                                          valStart.getUtcTime(), valEnd.getUtcTime(),
                                          allDay, valStart.getOffset(), valEnd.getOffset(),
                                          true, true));
                }
                Collections.sort(list);
            }
            return list;
        }

        @Override
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_RULE_TYPE, RULE_SINGLE_DATES);
            meta.put(FN_RDATE_EXDATE, mRdateExdate.encodeMetadata());
            meta.put(FN_DEFAULT_DURATION, mDefaultDuration);
            if (mInvId != null)
                meta.put(FN_INVID, mInvId.encodeMetadata());
            return meta;
        }

        SingleDates(Metadata meta, TimeZoneMap tzmap)
        throws ServiceException, ParseException {
            Metadata rexdate = meta.getMap(FN_RDATE_EXDATE);
            mRdateExdate = RdateExdate.decodeMetadata(rexdate, tzmap);
            mDefaultDuration = ParsedDuration.parse(meta.get(FN_DEFAULT_DURATION));
            Metadata metaInvId = meta.getMap(FN_INVID, true);
            if (metaInvId != null)
                mInvId = InviteInfo.fromMetadata(metaInvId, tzmap);
            setDates();
        }

        public SingleDates(RdateExdate rexdate, ParsedDuration defaultDuration) {
            this(rexdate, defaultDuration, null);
        }

        SingleDates(RdateExdate rexdate, ParsedDuration defaultDuration, InviteInfo invId) {
            mRdateExdate = rexdate;
            mDefaultDuration = defaultDuration;
            mInvId = invId;
            setDates();
        }

        private void setDates() {
            List<DateValue> list =
                new ArrayList<DateValue>(mRdateExdate.numValues());
            for (Iterator<Object> iter = mRdateExdate.valueIterator(); iter.hasNext(); ) {
                Object val = iter.next();
                if (val instanceof ParsedDateTime) {
                    ParsedDateTime start = (ParsedDateTime) val;
                    ParsedDateTime end = start.add(mDefaultDuration);
                    DateValue dtval = new DateValue(start, end);
                    list.add(dtval);
                } else if (val instanceof Period) {
                    Period p = (Period) val;
                    DateValue dtval = new DateValue(p.getStart(), p.getEnd());
                    list.add(dtval);
                }
            }
            mDates = list;
        }

        @Override
        public Element toXml(Element parent) {
            return mRdateExdate.toXml(parent);
        }

        @Override
        public Object clone() {
            return new SingleDates(mRdateExdate == null ? null : (RdateExdate) mRdateExdate.clone(),
                                   mDefaultDuration == null ? null : (ParsedDuration) mDefaultDuration.clone(),
                                   mInvId == null ? null : (InviteInfo) mInvId.clone());
        }

        private final RdateExdate mRdateExdate;
        private final ParsedDuration mDefaultDuration;
        private InviteInfo mInvId;
        private List<DateValue> mDates;

        private static class DateValue {

            private final ParsedDateTime mStart;
            private final ParsedDateTime mEnd;

            public DateValue(ParsedDateTime start, ParsedDateTime end) {
                assert(start != null && end != null);
                mStart = start;
                mEnd = end;
            }

            public ParsedDateTime getStartTime() { return mStart; }
            public ParsedDateTime getEndTime()   { return mEnd; }

            @Override
            public String toString() {
                StringBuilder sb = new StringBuilder();
                sb.append("[start=").append(mStart.toString());
                sb.append(", end=").append(mEnd.toString());
                sb.append("]");
                return sb.toString();
            }
        }
    }

    /**
     * @author tim
     *
     * The output of an RRULE or EXRULE rule -- corresponds to a RECUR value in an iCal specification
     *
     */
    public static class SimpleRepeatingRule implements IInstanceGeneratingRule {
        Map<String, List<Instance>> expandMap = new HashMap<String, List<Instance>>();
        public SimpleRepeatingRule(ParsedDateTime dtstart, ParsedDuration duration,
                ZRecur recur, InviteInfo invId)
        {
            mDtStart = dtstart;
            mRecur = recur;
            fixupRecurUntil();
            mInvId = invId;
            mDuration = duration;
            if (mDuration == null) {
                if (mDtStart != null && !mDtStart.hasTime())
                    mDuration = ParsedDuration.ONE_DAY;
                else
                    mDuration = ParsedDuration.ONE_SECOND;
            }
        }

        private void fixupRecurUntil() {
            if (mRecur != null && mDtStart != null) {
                ParsedDateTime until = mRecur.getUntil();
                if (until != null && until.hasTime() != mDtStart.hasTime()) {
                    // RFC5545 Section 3.3.10: UNTIL should have same value type as DTSTART.
                    if (mDtStart.hasTime()) {
                        // Add time part to UNTIL.  Set it to 23:59:59 in DTSTART's timezone, expressed as UTC.
                        Date dayEnd = until.getDateForRecurUntil(mDtStart.getTimeZone());
                        ParsedDateTime untilUtc = ParsedDateTime.fromUTCTime(dayEnd.getTime());
                        mRecur.setUntil(untilUtc);
                    } else {
                        until.setHasTime(false);
                    }
                }
            }
        }

        @Override
        public int getType() { return TYPE_REPEATING; }
        @Override
        public Iterator addRulesIterator() { return null; }
        @Override
        public Iterator subRulesIterator() { return null; }

        @Override
        public void setInviteId(InviteInfo invId) {
            mInvId = invId;
        }

        @Override
        public InviteInfo getInviteInfo() {
            return mInvId;
        }

        @Override
        public Element toXml(Element parent) {
            Element rule = parent.addElement(MailConstants.E_CAL_RULE);

            // FREQ
            String freq = IcalXmlStrMap.sFreqMap.toXml(mRecur.getFrequency().toString());
            rule.addAttribute(MailConstants.A_CAL_RULE_FREQ, freq);

            // UNTIL or COUNT
            ParsedDateTime untilDate = mRecur.getUntil();
            if (untilDate != null) {
                Element untilElt = rule.addElement(MailConstants.E_CAL_RULE_UNTIL);
                untilElt.addAttribute(MailConstants.A_CAL_DATETIME,
                                      untilDate.getDateTimePartString(false));
            } else {
                int count = mRecur.getCount();
                if (count > 0) {
                    rule.addElement(MailConstants.E_CAL_RULE_COUNT).addAttribute(MailConstants.A_CAL_RULE_COUNT_NUM, count);
                }
            }

            // INTERVAL
            int ival = mRecur.getInterval();
            if (ival > 0) {
                rule.addElement(MailConstants.E_CAL_RULE_INTERVAL).
                    addAttribute(MailConstants.A_CAL_RULE_INTERVAL_IVAL, ival);
            }

            // BYSECOND
            List<Integer> bySecond = mRecur.getBySecondList();
            if (!bySecond.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYSECOND).
                    addAttribute(MailConstants.A_CAL_RULE_BYSECOND_SECLIST, ZRecur.listAsStr(bySecond));
            }

            // BYMINUTE
            List <Integer> byMinute = mRecur.getByMinuteList();
            if (!byMinute.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYMINUTE).
                addAttribute(MailConstants.A_CAL_RULE_BYMINUTE_MINLIST, ZRecur.listAsStr(byMinute));
            }

            // BYHOUR
            List<Integer> byHour = mRecur.getByHourList();
            if (!byHour.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYHOUR).
                    addAttribute(MailConstants.A_CAL_RULE_BYHOUR_HRLIST, ZRecur.listAsStr(byHour));
            }

            // BYDAY
            List<ZRecur.ZWeekDayNum> byDay = mRecur.getByDayList();
            if (!byDay.isEmpty()) {
                Element bydayElt = rule.addElement(MailConstants.E_CAL_RULE_BYDAY);
                for (ZRecur.ZWeekDayNum wdn : byDay) {
                    Element wkdayElt = bydayElt.addElement(MailConstants.E_CAL_RULE_BYDAY_WKDAY);
                    if (wdn.mOrdinal != 0)
                        wkdayElt.addAttribute(MailConstants.A_CAL_RULE_BYDAY_WKDAY_ORDWK, wdn.mOrdinal);
                    wkdayElt.addAttribute(MailConstants.A_CAL_RULE_DAY, wdn.mDay.toString());
                }
            }

            // BYMONTHDAY
            List<Integer> byMonthDay = mRecur.getByMonthDayList();
            if (!byMonthDay.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYMONTHDAY).
                   addAttribute(MailConstants.A_CAL_RULE_BYMONTHDAY_MODAYLIST, ZRecur.listAsStr(byMonthDay));
            }

            // BYYEARDAY
            List<Integer> byYearDay = mRecur.getByYearDayList();
            if (!byYearDay.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYYEARDAY).
                    addAttribute(MailConstants.A_CAL_RULE_BYYEARDAY_YRDAYLIST, ZRecur.listAsStr(byYearDay));
            }

            // BYWEEKNO
            List<Integer> byWeekNo = mRecur.getByWeekNoList();
            if (!byWeekNo.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYWEEKNO).
                    addAttribute(MailConstants.A_CAL_RULE_BYWEEKNO_WKLIST, ZRecur.listAsStr(byWeekNo));
            }

            // BYMONTH
            List<Integer> byMonth = mRecur.getByMonthList();
            if (!byMonth.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYMONTH).
                    addAttribute(MailConstants.A_CAL_RULE_BYMONTH_MOLIST, ZRecur.listAsStr(byMonth));
            }

            // BYSETPOS
            List<Integer> bySetPos = mRecur.getBySetPosList();
            if (!bySetPos.isEmpty()) {
                rule.addElement(MailConstants.E_CAL_RULE_BYSETPOS).
                   addAttribute(MailConstants.A_CAL_RULE_BYSETPOS_POSLIST, ZRecur.listAsStr(bySetPos));
            }

            // WKST
            ZWeekDay wkst = mRecur.getWkSt();
            if (wkst != null) {
                rule.addElement(MailConstants.E_CAL_RULE_WKST).
                    addAttribute(MailConstants.A_CAL_RULE_DAY, wkst.toString());
            }

//            // x-name
//            Map xNames = mRecur.getExperimentalValues();
//            for (Iterator iter = mRecur.getExperimentalValues().entrySet().iterator();
//                 iter.hasNext(); ) {
//                Map.Entry entry = (Map.Entry) iter.next();
//                Element xElt = rule.addElement(MailService.E_CAL_RULE_XNAME);
//                xElt.addAttribute(MailService.A_CAL_RULE_XNAME_NAME, (String) entry.getKey());
//                xElt.addAttribute(MailService.A_CAL_RULE_XNAME_VALUE, (String) entry.getValue());
//            }

            return rule;
        }

        @Override
        public List<Instance> expandInstances(int calItemId, long start, long end)
        {
            if (mDtStart == null) {
                ZimbraLog.calendar.warn("Unable to expand a recurrence with no DTSTART");
                return new ArrayList<Instance>();
            }
            String KEY = String.valueOf(calItemId) + '-' + start + '-' + end;
            List<Instance> toRet = expandMap.get(KEY);
            if (toRet != null) {
                return toRet;
            }
            ICalTimeZone tz = mDtStart.getTimeZone();
            if (tz == null)
                tz = ICalTimeZone.getUTC();
            try {
                long duration = 0;
                if (mDuration != null) {
                    ParsedDateTime et = mDtStart.add(mDuration);
                    duration = et.getUtcTime() - mDtStart.getUtcTime();
                }
                List <java.util.Date> dateList = mRecur.expandRecurrenceOverRange(mDtStart, start - duration, end);

                toRet = new ArrayList<Instance>(dateList.size());

                int num = 0;
                for (Iterator iter = dateList.iterator(); iter.hasNext();) {
                    Date cur = (Date)iter.next();
                    long instStart = cur.getTime();
                    long instEnd;
                    if (mDuration != null) {
                        ParsedDateTime startDt = ParsedDateTime.fromUTCTime(instStart, tz);
                        instEnd = startDt.add(mDuration).getUtcTime();
                    } else {
                        instEnd = instStart;
                    }
                    if (instStart < end && instEnd > start) {
                        int startTzo = tz.getOffset(instStart);
                        int endTzo = tz.getOffset(instEnd);
                        boolean allDay = !mDtStart.hasTime() || (mDtStart.hasZeroTime() && mDuration != null && mDuration.isMultipleOfDays());
                        toRet.add(num++, new Instance(calItemId, mInvId, true, true, instStart, instEnd,
                                allDay, startTzo, endTzo, false, false));
                    }
                }
            } catch (ServiceException se) {
                // Bugs 3172 and 3240.  Ignore recurrence rules with bad data.
                ZimbraLog.calendar.warn("ServiceException expanding recurrence rule: " + mRecur.toString(), se);
                toRet = new ArrayList<Instance>();
            } catch (IllegalArgumentException iae) {
                // Bugs 3172 and 3240.  Ignore recurrence rules with bad data.
            	ZimbraLog.calendar.warn("Invalid recurrence rule: " + mRecur.toString(), iae);
                toRet = new ArrayList<Instance>();
            }
            // cache and return;
            expandMap.put(KEY, toRet);
            return toRet;
        }

        public ZRecur getRule() { return mRecur; }


        @Override
        public ParsedDateTime getStartTime() {
            return mDtStart;
        }
        @Override
        public ParsedDateTime getEndTime() throws ServiceException {
            if (mDtStart == null) {
                // VTODOs don't have to have DTSTART
                return ParsedDateTime.MAX_DATETIME;
            } else if (mRecur != null) {
                long endMillis = mRecur.getEstimatedEndTime(mDtStart).getTime();
                if (mRecur.getCount() > 0) {
                    // If recurrence is limited by COUNT, run the expansion to figure out the true end time.
                    List<Date> dates = mRecur.expandRecurrenceOverRange(mDtStart, mDtStart.getUtcTime(), endMillis);
                    if (!dates.isEmpty())
                        endMillis = dates.get(dates.size() - 1).getTime();
                }
                ParsedDateTime end = ParsedDateTime.fromUTCTime(endMillis, mDtStart.getTimeZone());
                if (mDuration != null)
                    end = end.add(mDuration);
                return end;
            } else {
                // non-recurring or invalid rule; assume single instance, end = start + duration
                ParsedDuration dur = mDuration != null ? mDuration : ParsedDuration.parse(false, 0, 0, 0, 0, 1);
                return mDtStart.add(dur);
            }
        }

        @Override
        public String toString() {
            StringBuilder toRet = new StringBuilder();
            toRet.append("RULE(FIRST=").append(mDtStart != null ? mDtStart.getDate() : "<none>");
            toRet.append(",DUR=").append(mDuration);
            toRet.append(",RECUR=").append(mRecur.toString());
            return toRet.toString();
        }

        private static final String FN_DTSTART = "dts";
        private static final String FN_DURATION = "dur";
        private static final String FN_RECUR = "recur";
        private static final String FN_INVID = "inv";

        @Override
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_RULE_TYPE, RULE_SIMPLE_REPEATING_RULE);
            meta.put(FN_DTSTART, mDtStart);
            meta.put(FN_DURATION, mDuration);
            meta.put(FN_RECUR, mRecur);
            if (mInvId != null)
                meta.put(FN_INVID, mInvId.encodeMetadata());

            return meta;
        }

        @Override
        public Object clone() {
            return new SimpleRepeatingRule(mDtStart == null ? null : (ParsedDateTime) mDtStart.clone(),
                                           mDuration == null ? null : (ParsedDuration) mDuration.clone(),
                                           mRecur == null ? null : (ZRecur) mRecur.clone(),
                                           mInvId == null ? null : (InviteInfo) mInvId.clone());
        }

        public SimpleRepeatingRule(Metadata meta, TimeZoneMap tzmap) throws ServiceException {
            try {
                mDtStart = ParsedDateTime.parse(meta.get(FN_DTSTART, null), tzmap);
                mDuration = ParsedDuration.parse(meta.get(FN_DURATION, null));
                if (mDuration == null) {
                    if (mDtStart != null && !mDtStart.hasTime())
                        mDuration = ParsedDuration.ONE_DAY;
                    else
                        mDuration = ParsedDuration.ONE_SECOND;
                }
            } catch (ParseException e) {
                throw ServiceException.FAILURE("ParseException ", e);
            }
            mRecur = new ZRecur(meta.get(FN_RECUR).toString(), tzmap);
            Metadata metaInvId = meta.getMap(FN_INVID, true);
            if (metaInvId != null)
                mInvId = InviteInfo.fromMetadata(metaInvId, tzmap);
        }

        // define the value
        private ParsedDateTime mDtStart;
        private final ZRecur mRecur;
        private ParsedDuration mDuration;
        private InviteInfo mInvId;
    }

    /**
     * @author tim
     *
     * Base class: models a set of rules as
     *    DTSTART + (RRULEs + RDATEs - EXRULEs - EXDATEs)
     *
     *
     *  Not instantiated directly -- used to build either a Rule (which can have Exceptions) or
     *  an ExceptionRule (ie component with a RECURRENCE-ID property)
     *
     */
    public static abstract class CompoundRuleBase implements IRecurrence {
        protected CompoundRuleBase(ParsedDateTime dtstart, ParsedDuration duration, InviteInfo invId,
                List<IRecurrence> addRules,
                List<IRecurrence> subtractRules)
        {
            mDtStart = dtstart;
            mDuration = duration;
            if (mDuration == null) {
                if (mDtStart != null && !mDtStart.hasTime())
                    mDuration = ParsedDuration.ONE_DAY;
                else
                    mDuration = ParsedDuration.ONE_SECOND;
            }
            mInvId = invId;
            mAddRules = new MultiRuleSorter(addRules);
            if (subtractRules.size() > 0) {
                mSubtractRules = new MultiRuleSorter(subtractRules);
            } else {
                mSubtractRules = null;
            }
        }

        @Override
        public void setInviteId(InviteInfo invId) {
            mInvId = invId;

            mAddRules.setInviteId(invId);
            if (mSubtractRules != null) {
                mSubtractRules.setInviteId(invId);
            }
        }

        @Override
        public InviteInfo getInviteInfo() {
            return mInvId;
        }

        protected CompoundRuleBase(ParsedDateTime dtstart, ParsedDuration duration,
                InviteInfo invId)
        {
            mDtStart = dtstart;
            mDuration = duration;
            if (mDuration == null) {
                if (mDtStart != null && !mDtStart.hasTime())
                    mDuration = ParsedDuration.ONE_DAY;
                else
                    mDuration = ParsedDuration.ONE_SECOND;
            }
            mInvId = invId;
            mAddRules = null;
            mSubtractRules = null;
        }

        @Override
        public Iterator<IRecurrence> addRulesIterator() { return mAddRules.iterator(); }
        @Override
        public Iterator<IRecurrence> subRulesIterator() {
            if (mSubtractRules != null) {
                return mSubtractRules.iterator();
            }
            return null;
        }


        @Override
        public List<Instance> expandInstances(int calItemId, long start, long end)
        throws ServiceException {
            if (mDtStart == null) {
                ZimbraLog.calendar.warn("Unable to expand a recurrence with no DTSTART");
                return new ArrayList<Instance>(0);
            }

            // expansion = DTSTART + RRULEs + RDATEs - (EXRULEs + EXDATEs)

            // RRULEs + RDATEs
            List<Instance> toAdd;
            if (mAddRules != null)
                toAdd = mAddRules.expandInstances(calItemId, start, end);
            else
                toAdd = new ArrayList<Instance>(1);

            // DTSTART
            long firstStart = mDtStart.getUtcTime();
            ParsedDateTime dtFirstEnd = mDuration != null ? mDtStart.add(mDuration) : null;
            long firstEnd = dtFirstEnd != null ? dtFirstEnd.getUtcTime() : firstStart;
            if (firstStart < end && firstEnd > start) {
                CalendarItem.Instance first = null;
                if (toAdd.size() > 0) {
                    first = toAdd.get(0);
                }

                boolean allDay = !mDtStart.hasTime() || (mDtStart.hasZeroTime() && mDuration != null && mDuration.isMultipleOfDays());
                CalendarItem.Instance dtstartInst = new CalendarItem.Instance(
                        calItemId, mInvId, true, true, firstStart, firstEnd,
                        allDay, mDtStart.getOffset(), dtFirstEnd != null ? dtFirstEnd.getOffset() : 0,
                        false, true);
                if (first == null || first.compareTo(dtstartInst) != 0)
                    toAdd.add(0,dtstartInst);
            }

            // -(EXRULEs + EXDATEs)
            if (mSubtractRules == null)
                return toAdd;
            List<Instance> toExclude = mSubtractRules.expandInstances(calItemId, start, end);
            return ListUtil.subtractSortedLists(
                    toAdd, toExclude, new Instance.StartTimeComparator());
        }

        @Override
        public Element toXml(Element parent) {
            if (mAddRules != null) {
                Element addElt = parent.addElement(MailConstants.E_CAL_ADD);
                mAddRules.toXml(addElt);
            }
            if (mSubtractRules != null) {
                Element excludeElt = parent.addElement(MailConstants.E_CAL_EXCLUDE);
                mSubtractRules.toXml(excludeElt);
            }
            return parent;
        }


        @Override
        public ParsedDateTime getStartTime() {
            return mDtStart;
        }

        @Override
        public ParsedDateTime getEndTime() throws ServiceException {
            if (mAddRules != null) {
                return mAddRules.getEndTime(); // FIXME should take into account EXCEPTIONS?
            } else if (mDtStart != null) {
                return mDtStart.add(mDuration);
            } else {
                return null;
            }
        }

        static final String FN_DTSTART = "dts";
        static final String FN_DURATION = "duration";
        static final String FN_ADDRULES = "add";
        static final String FN_SUBRULES = "sub";
        static final String FN_INVID = "invid";

        @Override
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();
            meta.put(FN_DTSTART, mDtStart);
            meta.put(FN_DURATION, mDuration);
            if (mAddRules != null)
                meta.put(FN_ADDRULES, mAddRules.encodeMetadata());
            if (mSubtractRules != null)
                meta.put(FN_SUBRULES, mSubtractRules.encodeMetadata());
            if (mInvId != null)
                meta.put(FN_INVID, mInvId.encodeMetadata());

            return meta;
        }

        protected CompoundRuleBase(Metadata meta, TimeZoneMap tzmap)
        throws ServiceException, ParseException {
            String str = meta.get(FN_DTSTART, null);
            mDtStart = ParsedDateTime.parse(str, tzmap);
            mDuration = ParsedDuration.parse(meta.get(FN_DURATION, null));
            if (mDuration == null) {
                if (mDtStart != null && !mDtStart.hasTime())
                    mDuration = ParsedDuration.ONE_DAY;
                else
                    mDuration = ParsedDuration.ONE_SECOND;
            }

            Metadata metaRules = meta.getMap(FN_ADDRULES, true);
            if (metaRules != null) {
                mAddRules = new MultiRuleSorter(metaRules, tzmap);
            }
            Metadata metaSubrules = meta.getMap(FN_SUBRULES, true);
            if (metaSubrules != null) {
                mSubtractRules = new MultiRuleSorter(metaSubrules, tzmap);
            }

            Metadata metaInvId = meta.getMap(FN_INVID, true);
            if (metaInvId != null)
                mInvId = InviteInfo.fromMetadata(metaInvId, tzmap);
        }

        protected CompoundRuleBase(ParsedDateTime dtstart, ParsedDuration duration,
                MultiRuleSorter addRules, MultiRuleSorter subtractRules,
                InviteInfo invID)
        {
            mDtStart = dtstart;
            mDuration = duration;
            if (mDuration == null) {
                if (mDtStart != null && !mDtStart.hasTime())
                    mDuration = ParsedDuration.ONE_DAY;
                else
                    mDuration = ParsedDuration.ONE_SECOND;
            }
            mAddRules = addRules;
            mSubtractRules = subtractRules;
            mInvId = invID;
        }

        @Override
        public String toString() {
            StringBuffer toRet = new StringBuffer();
            toRet.append("FIRST=").append(mDtStart != null ? mDtStart.getDate() : "<none>");
            toRet.append(",DUR=").append(mDuration);
            if (mAddRules != null) {
                toRet.append("\n\t\tADD[").append(mAddRules.toString()).append("]");
            }
            if (mSubtractRules != null) {
                toRet.append("\n\t\tSUBTRACT[").append(mSubtractRules.toString()).append("]");
            }
            return toRet.toString();
        }

        @Override
        public abstract Object clone();

        protected ParsedDateTime mDtStart;
        protected ParsedDuration mDuration;

        protected MultiRuleSorter mAddRules; // RRULE, RDATE
        protected MultiRuleSorter mSubtractRules; // RRULE, RDATE
        protected InviteInfo mInvId;
    }

//
// This is commented-out for compatability (not supported by many CUAs) --but leave the code here hopefully
// we can figure out a way to enable it eventually...
//
//
//    /**
//     * @author tim
//     *
//     * Represents the range of instances specified by a RECURRENCE_ID iCalendar component
//     */
//    public static class RecurrenceRange
//    {
//        public static final int NOT_RANGE = 1;
//        public static final int THIS_AND_FUTURE = 2;
//        public static final int THIS_AND_PRIOR = 3;
//
//        static final String FN_RANGE_TYPE = "rgtyp";
//        static final String FN_RECURRENCE_ID = "recurId";
//
//        private ParsedDateTime mRecurrenceId;
//        private int mRangeType = NOT_RANGE;
//
//        RecurrenceRange(ParsedDateTime recurrenceId, int rangeType) {
//            mRecurrenceId = recurrenceId;
//            assert(rangeType == NOT_RANGE || rangeType == THIS_AND_FUTURE || rangeType == THIS_AND_PRIOR);
//            mRangeType = rangeType;
//        }
//
//        public Metadata encodeMetadata()
//        {
//            Metadata meta = new Metadata();
//
//            meta.put(FN_RECURRENCE_ID, mRecurrenceId);
//            meta.put(FN_RANGE_TYPE, Integer.toString(mRangeType));
//
//            return meta;
//        }
//
//        protected RecurrenceRange(Metadata meta, TimeZoneMap tzMap) throws ServiceException, ParseException
//        {
//            mRecurrenceId = ParsedDateTime.parse(meta.get(FN_RECURRENCE_ID), tzMap);
//            mRangeType = (int)meta.getLong(FN_RANGE_TYPE);
//        }
//
//        public boolean matches(long date) {
//            // TODO we don't currently handle ranges!
//            return (mRecurrenceId.compareTo(date) == 0);
//        }
//
//
//        public String toString() {
//            StringBuffer toRet = new StringBuffer();
//            switch (mRangeType) {
//            case NOT_RANGE:
//                toRet.append("(RECURRENCE-ID=").append(mRecurrenceId.toString()).append(")");
//                break;
//            case THIS_AND_FUTURE:
//                toRet.append("(RECURRENCE-ID=RANGE:THISANDFUTURE;").append(mRecurrenceId.toString()).append(")");
//                break;
//            case THIS_AND_PRIOR:
//                toRet.append("(RECURRENCE-ID=RANGE:THISANDPRIOR;").append(mRecurrenceId.toString()).append(")");
//                break;
//            }
//            return toRet.toString();
//        }
//    }

    /**
     * @author tim
     *
     * an RFC2446 CANCEL request to cancel an instance or range of instances
     *
     * basically, this intercepts one or more Recurrence instances, and replaces them with nothing
     */
    public static class CancellationRule implements IException
    {
        static private final String FN_RECURRENCE_ID = "recurId";

        private final RecurId mRecurRange;

        public CancellationRule(RecurId recurId) {
            mRecurRange = recurId;
        }

        @Override
        public int getType() { return TYPE_CANCELLATION; }
        @Override
        public Iterator addRulesIterator() { return null; }
        @Override
        public Iterator subRulesIterator() { return null; }

        @Override
        public void setInviteId(InviteInfo invId) {}
        @Override
        public InviteInfo getInviteInfo() { return null; }

        CancellationRule(Metadata meta, TimeZoneMap tzmap)
        throws ServiceException, ParseException
        {
            mRecurRange = RecurId.decodeMetadata(meta.getMap(FN_RECURRENCE_ID), tzmap);
        }

        @Override
        public Metadata encodeMetadata() {
            Metadata meta = new Metadata();

            meta.put(FN_RECURRENCE_ID, mRecurRange.encodeMetadata());
            return meta;
        }

        @Override
        public List<Instance> expandInstances(int calItemId, long start, long end) {
            return new ArrayList<Instance>(); // NONE!
        }

        @Override
        public ParsedDateTime getStartTime() {
            return null;
        }

        @Override
        public ParsedDateTime getEndTime() {
            return null;
        }

        @Override
        public Object clone() {
            return new CancellationRule(mRecurRange == null ? null : (RecurId) mRecurRange.clone());
        }

        @Override
        public Element toXml(Element parent) {
            Element elt = parent.addElement(MailConstants.E_CAL_CANCEL);
            mRecurRange.toXml(elt);

            return elt;
        }

        @Override
        public boolean matches(long date) {
            return mRecurRange.withinRange(date);
        }

        @Override
        public RecurId getRecurId() {
            return mRecurRange;
        }

        @Override
        public String toString() {
            return String.format("CANCELLATION(%s)", mRecurRange == null ? "<null>" : mRecurRange.toString());
        }
    }


    /**
     * @author tim
     *
     * A recurrence-rule that has a RECURRENCE-ID and can tell you if it applies
     * or not
     */
    public static class ExceptionRule extends CompoundRuleBase implements IException
    {
        public ExceptionRule(RecurId recurrenceId,
                ParsedDateTime dtstart, ParsedDuration duration,
                InviteInfo invId,
                List<IRecurrence> addRules, List<IRecurrence> subtractRules)
        {
            super(dtstart, duration, invId, addRules, subtractRules);
            mRecurRange = recurrenceId;
        }

        public ExceptionRule(RecurId recurrenceId,
                ParsedDateTime dtstart, ParsedDuration duration,
                InviteInfo invId)
        {
            super(dtstart, duration, invId);
            mRecurRange = recurrenceId;
        }

        protected ExceptionRule(Metadata meta, TimeZoneMap tzmap) throws ParseException, ServiceException
        {
            super(meta, tzmap);
            mRecurRange = RecurId.decodeMetadata(meta.getMap(FN_RECURRENCE_ID), tzmap);
        }

        @Override
        public int getType() { return TYPE_EXCEPTION; }

        @Override
        public List<Instance> expandInstances(int calItemId, long start, long end)
        throws ServiceException {
            List<Instance> toRet = super.expandInstances(calItemId, start, end);

            for (Iterator iter = toRet.iterator(); iter.hasNext();) {
                CalendarItem.Instance cur = (CalendarItem.Instance)iter.next();
                cur.setIsException(true);
            }
            return toRet;
        }


        @Override
        public Element toXml(Element parent) {
            Element elt = parent.addElement(MailConstants.E_CAL_EXCEPT);
            mRecurRange.toXml(elt);

            // now put the
            super.toXml(elt);

            return elt;
        }

        static final String FN_RECURRENCE_ID = "recurId";
        static final String FN_RANGE_TYPE = "rgtyp";
        @Override
        public Metadata encodeMetadata()
        {
            Metadata meta = super.encodeMetadata();
            meta.put(FN_RULE_TYPE, RULE_EXCEPTION_RULE);
            meta.put(FN_RECURRENCE_ID, mRecurRange.encodeMetadata());
            return meta;
        }

        @Override
        public boolean matches(long date) {
            return mRecurRange.withinRange(date);
        }

        @Override
        public RecurId getRecurId() {
            return mRecurRange;
        }

        @Override
        public String toString() {
            StringBuffer toRet = new StringBuffer("EXCEPTION(");
            toRet.append(mRecurRange.toString());
            toRet.append(" ");
            toRet.append(super.toString());
            return toRet.toString();
        }

        private ExceptionRule(ExceptionRule other) {
            super(other.mDtStart == null ? null : (ParsedDateTime) other.mDtStart.clone(),
                  other.mDuration == null ? null : (ParsedDuration) other.mDuration.clone(),
                  other.mAddRules == null ? null : (MultiRuleSorter) other.mAddRules.clone(),
                  other.mSubtractRules == null ? null : (MultiRuleSorter) other.mSubtractRules.clone(),
                  other.mInvId == null ? null : (InviteInfo) other.mInvId.clone());
            mRecurRange = other.mRecurRange == null ? null : (RecurId) other.mRecurRange.clone();
        }

        @Override
        public Object clone() {
            return new ExceptionRule(this);
        }

        private final RecurId mRecurRange;
    }

    /**
     * @author tim
     *
     * Models the initial "master" rule in a ruleset -- ie the one and only component for a
     * particular UID that has no RECURRENCE-ID setting
     *
     * To get the output of this rule you basically:
     *     For each Instance:   ( DTSTART + (RRULEs+RDATES-EXRULEs-EXDATEs) )
     *        Check the RECURRENCE-ID of each Exception
     *           if it matches, then use that Exceptions Instances
     *           else return the Instance
     *
     */
    public static class RecurrenceRule extends CompoundRuleBase
    {
        public RecurrenceRule(ParsedDateTime dtstart, ParsedDuration duration,
                InviteInfo invId,
                List<IRecurrence> addRules, List<IRecurrence> subtractRules)
        {
            super(dtstart, duration, invId, addRules, subtractRules);
            mExceptions = new ArrayList<IException>();
        }

        public RecurrenceRule(ParsedDateTime dtstart, ParsedDuration duration,
                InviteInfo invId)
        {
            super(dtstart, duration, invId);
            mExceptions = new ArrayList<IException>();
        }

        @Override
        public int getType() { return TYPE_RECURRENCE; }

        @Override
        public void setInviteId(InviteInfo invId) {
            super.setInviteId(invId);
            assert(mExceptions.size() == 0); // must not call this on an calendar item-owned Invite
        }

        public Iterator<IException> exceptionsIter() {
            return mExceptions.iterator();
        }

        public RecurrenceRule(Metadata meta, TimeZoneMap tzmap)
        throws ServiceException, ParseException {
            super(meta, tzmap);

            int numEx = (int) meta.getLong(FN_NUM_EXCEPTIONS);
            mExceptions = new ArrayList<IException>(numEx);

            for (int i = 0; i < numEx; i++) {
                if (meta.containsKey(FN_EXCEPTION+i)) {
                    mExceptions.add(i, new ExceptionRule(meta.getMap(FN_EXCEPTION+i), tzmap));
                } else if (meta.containsKey(FN_CANCELLATION+i)) {
                    mExceptions.add(i, new CancellationRule(meta.getMap(FN_CANCELLATION+i), tzmap));
                }
            }
        }

        @Override
        public Element toXml(Element parent) {
            for (Iterator iter = mExceptions.iterator(); iter.hasNext();) {
                IException cur = (IException)iter.next();
                cur.toXml(parent);
            }
            super.toXml(parent);

            return parent;
        }


        public void addException(IException rule) {
            mExceptions.add(rule);
        }

        @Override
        public List<Instance> expandInstances(int calItemId, long start, long end) throws ServiceException {
            long startAdjusted = start;
            long endAdjusted = end;
            // Stretch the start/end times to ensure all exception instances are included.
            for (IException except : mExceptions) {
                if (except != null) {
                    RecurId rid = except.getRecurId();
                    if (rid != null) {
                        ParsedDateTime dt = rid.getDt();
                        if (dt != null) {
                            long recurIdTime = dt.getUtcTime();
                            ParsedDateTime st = except.getStartTime();
                            if (st != null) {
                                long stTime = st.getUtcTime();
                                if (stTime >= start && stTime < end) {
                                    if (recurIdTime < startAdjusted)
                                        startAdjusted = recurIdTime;
                                    else if (recurIdTime > endAdjusted)
                                        endAdjusted = recurIdTime + 1;
                                }
                            }
                            if (end < Long.MAX_VALUE) {
                                ParsedDateTime et = except.getEndTime();
                                if (et != null) {
                                    long etTime = et.getUtcTime();
                                    if (etTime > start && etTime <= end) {
                                        if (recurIdTime < startAdjusted)
                                            startAdjusted = recurIdTime;
                                        else if (recurIdTime > endAdjusted)
                                            endAdjusted = recurIdTime + 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // get the list of instances that THIS rule expands into
            List<Instance> stdInstances = super.expandInstances(calItemId, startAdjusted, endAdjusted);

            // Iterate the expanded instances and eliminate instances whose start time:
            // 1) lies outside the [start, end) range
            // 2) or matches RECURRENCE-ID of one of the exceptions.
            for (Iterator<Instance> iter = stdInstances.iterator(); iter.hasNext(); ) {
                Instance inst = iter.next();
                if (inst != null) {
                    if (inst.getEnd() < start || inst.getStart() >= end) {
                        // Restrict to [start, end) range.
                        iter.remove();
                    } else {
                        for (IException except : mExceptions) {
                            if (except != null) {
                                long instStart = inst.getStart();
                                if (inst.isAllDay()) {
                                    // Adjust start time value from instance's TZ to exception's TZ.
                                    RecurId eRid = except.getRecurId();
                                    if (eRid != null && eRid.getDt() != null) {
                                        long eOffset = eRid.getDt().getOffset();
                                        long iOffset = inst.getStartTzOffset();
                                        if (iOffset != eOffset)
                                            instStart += iOffset - eOffset;
                                    }
                                }
                                if (except.matches(instStart)) {
                                    iter.remove();
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // Expand and add all exceptions in the range.
            List<List<Instance>> exceptionInstancesList = new ArrayList<List<Instance>>();
            for (IException except : mExceptions) {
                if (except != null) {
                    List<Instance> instances = except.expandInstances(calItemId, startAdjusted, endAdjusted);
                    // Restrict to [start, end) range.
                    for (Iterator<Instance> iter = instances.iterator(); iter.hasNext(); ) {
                        Instance inst = iter.next();
                        if (inst != null) {
                            long st = inst.getStart();
                            long et = inst.getEnd();
                            if (et < start || st >= end)
                                iter.remove();
                        }
                    }
                    if (!instances.isEmpty())
                        exceptionInstancesList.add(instances);
                }
            }

            // Combine all rule and exception instances.
            List<Instance> toRet;
            if (exceptionInstancesList.isEmpty()) {
                toRet = stdInstances;
            } else {
                toRet = new ArrayList<Instance>();
                List<Instance> toAdd[] = new List[exceptionInstancesList.size() + 1];
                toAdd[0] = stdInstances;
                int offset = 1;
                for (List<Instance> except : exceptionInstancesList) {
                    toAdd[offset++] = except;
                }
                ListUtil.mergeSortedLists(toRet, toAdd, true);
            }

            return toRet;
        }

        @Override
        public String toString() {
            StringBuffer toRet = new StringBuffer();

            toRet.append("RECUR(").append(super.toString());
            for (Iterator iter = mExceptions.iterator(); iter.hasNext();) {
                IException ex = (IException)iter.next();
                toRet.append("\n\t\t").append(ex.toString());
            }
            toRet.append(")");

            return toRet.toString();
        }


        static final String FN_NUM_EXCEPTIONS = "numEx";
        static final String FN_EXCEPTION = "ex";
        static final String FN_CANCELLATION = "ca";

        @Override
        public Metadata encodeMetadata()
        {
            Metadata meta = super.encodeMetadata();

            meta.put(FN_RULE_TYPE, Integer.toString(RULE_RECURRENCE_RULE));
            meta.put(FN_NUM_EXCEPTIONS, Integer.toString(mExceptions.size()));
            for (int i = 0; i < mExceptions.size(); i++) {
                IException cur = mExceptions.get(i);
                if (cur instanceof ExceptionRule) {
                    meta.put(FN_EXCEPTION+i, cur.encodeMetadata());
                } else {
                    meta.put(FN_CANCELLATION+i, cur.encodeMetadata());
                }
            }
            return meta;
        }

        private RecurrenceRule(RecurrenceRule other) {
            super(other.mDtStart == null ? null : (ParsedDateTime) other.mDtStart.clone(),
                  other.mDuration == null ? null : (ParsedDuration) other.mDuration.clone(),
                  other.mAddRules == null ? null : (MultiRuleSorter) other.mAddRules.clone(),
                  other.mSubtractRules == null ? null : (MultiRuleSorter) other.mSubtractRules.clone(),
                  other.mInvId == null ? null : (InviteInfo) other.mInvId.clone());
            mExceptions = new ArrayList<IException>();
            for (Iterator iter = other.mExceptions.iterator(); iter.hasNext();) {
                IException cur = (IException)iter.next();
                mExceptions.add((IException) cur.clone());
            }
        }

        @Override
        public Object clone() {
            return new RecurrenceRule(this);
        }


        protected List<IException> mExceptions;
    }

    public static List<Instance> expandInstances(IRecurrence recur, int calItemId, long start, long end)
    throws ServiceException {
        List<Instance> list = recur.expandInstances(calItemId, start, end);

        // Eliminate duplicate instances.  For example, an instance may be mentioned both as
        // a RDATE and an exception VEVENT.  Outlook seems to generate this type of data upon
        // update of series.  Always prefer exception VEVENT over RDATE.
        List<Instance> toRet = new ArrayList<Instance>(list.size());
        Instance prev = null;
        for (Instance inst : list) {
            if (prev == null) {
                prev = inst;
            } else if (inst != null) {
                if (inst.sameTime(prev)) {
                    // If previous and this instance have same time (are essentially the same thing),
                    // take the one that wasn't generated from RDATE.
                    if (!inst.fromRdate())
                        prev = inst;
                    // Else ignore current instance.
                } else {
                    // If prev and this have different time, prev was a good instance.  Add it.
                    toRet.add(prev);
                    prev = inst;
                }
            }
        }
        if (prev != null)
            toRet.add(prev);
        return toRet;
    }

    // Get the set of TZIDs referenced in a recurrence.  RDATE and EXDATE can use TZID parameter.
    public static Set<String> getReferencedTZIDs(IRecurrence recur) {
        Set<String> tzids = new HashSet<String>();
        // RDATE
        for (Iterator iter = recur.addRulesIterator(); iter!=null && iter.hasNext();) {
            IRecurrence cur = (IRecurrence) iter.next();
            if (cur.getType() == Recurrence.TYPE_SINGLE_DATES) {
                Recurrence.SingleDates sd = (Recurrence.SingleDates) cur;
                RdateExdate rdate = sd.getRdateExdate();
                ICalTimeZone tz = rdate.getTimeZone();
                if (tz != null)
                    tzids.add(tz.getID());
            }
        }
        // EXDATE
        for (Iterator iter = recur.subRulesIterator(); iter!=null && iter.hasNext();) {
            IRecurrence cur = (IRecurrence) iter.next();
            if (cur.getType() == Recurrence.TYPE_SINGLE_DATES) {
                Recurrence.SingleDates sd = (Recurrence.SingleDates) cur;
                RdateExdate exdate = sd.getRdateExdate();
                ICalTimeZone tz = exdate.getTimeZone();
                if (tz != null)
                    tzids.add(tz.getID());
            }
        }

        ParsedDateTime recurStart = recur.getStartTime();
        if (recurStart != null) {
            ICalTimeZone tz = recurStart.getTimeZone();
            if (tz != null)
                tzids.add(tz.getID());
        }

        return tzids;
    }

    // Returns true if two recurrences have the same series rules, ignoring any exception instances.
    // Assume there aren't multiple RRULEs per VEVENT/VTODO.
    public static boolean sameSeriesRules(IRecurrence r1, IRecurrence r2) {
        SimpleRepeatingRule rule1 = null, rule2 = null;
        for (Iterator iter1 = r1.addRulesIterator(); iter1.hasNext(); ) {
            Object obj = iter1.next();
            if (obj instanceof SimpleRepeatingRule && rule1 == null) {
                rule1 = (SimpleRepeatingRule) obj;
                break;
            }
        }
        for (Iterator iter2 = r2.addRulesIterator(); iter2.hasNext(); ) {
            Object obj = iter2.next();
            if (obj instanceof SimpleRepeatingRule && rule2 == null) {
                rule2 = (SimpleRepeatingRule) obj;
                break;
            }
        }
        if (rule1 != null && rule2 != null) {
            return StringUtil.equal(rule1.toString(), rule2.toString());
        } else {
            return rule1 == rule2;
        }
    }

    public static void main(String[] args) throws Exception {
        ICalTimeZone pacific = new ICalTimeZone(
                "America/Los_Angeles",
                -28800000, "16010101T020000", "FREQ=YEARLY;WKST=MO;INTERVAL=1;BYMONTH=11;BYDAY=1SU", "PST",
                -25200000, "16010101T020000", "FREQ=YEARLY;WKST=MO;INTERVAL=1;BYMONTH=3;BYDAY=2SU", "PDT");
        TimeZoneMap tzmap = new TimeZoneMap(pacific);
        String str = "TZID=\"" + pacific.getID() + "\":20090105T120000";
        ParsedDateTime dtStart = ParsedDateTime.parse(str, tzmap);
        ParsedDuration duration = ParsedDuration.parse("PT1H");

        List<IRecurrence> addRules = new ArrayList<IRecurrence>();
        List<IRecurrence> subRules = new ArrayList<IRecurrence>();

        // weekly from 2009/01/05, for 52 weeks
        ZRecur rule = new ZRecur("FREQ=WEEKLY;INTERVAL=1", tzmap);
        addRules.add(new SimpleRepeatingRule(dtStart, duration, rule, null));

        // add a couple of RDATES: 2009/01/06, 2009/01/07
        RdateExdate rdate = new RdateExdate(ICalTok.RDATE, pacific);
        str = "TZID=\"" + pacific.getID() + "\":20090106T120000";
        ParsedDateTime rd1 = ParsedDateTime.parse(str, tzmap);
        rdate.addValue(rd1);
        str = "TZID=\"" + pacific.getID() + "\":20090107T120000";
        ParsedDateTime rd2 = ParsedDateTime.parse(str, tzmap);
        rdate.addValue(rd2);
        addRules.add(new SingleDates(rdate, duration));

        // modify instance on 2009/02/16 to start at 1pm instead of noon, for 2 hours
        str = "TZID=\"" + pacific.getID() + "\":20090216T120000";
        ParsedDateTime ridDtModify1 = ParsedDateTime.parse(str, tzmap);
        RecurId ridModify1 = new RecurId(ridDtModify1, RecurId.RANGE_NONE);
        str = "TZID=\"" + pacific.getID() + "\":20090216T130000";
        ParsedDateTime dtStartModify1 = ParsedDateTime.parse(str, tzmap);
        ParsedDuration durModify1 = ParsedDuration.parse("PT2H");
        ExceptionRule modify1 = new ExceptionRule(ridModify1, dtStartModify1, durModify1, null);

        // cancel instance on 2009/01/19
        str = "TZID=\"" + pacific.getID() + "\":20090119T120000";
        ParsedDateTime dtCancel1 = ParsedDateTime.parse(str, tzmap);
        RecurId ridCancel1 = new RecurId(dtCancel1, RecurId.RANGE_NONE);
        CancellationRule cancel1 = new CancellationRule(ridCancel1);

        // EXDATE on 2009/02/09
        RdateExdate exdate = new RdateExdate(ICalTok.EXDATE, pacific);
        str = "TZID=\"" + pacific.getID() + "\":20090209T120000";
        ParsedDateTime ex1 = ParsedDateTime.parse(str, tzmap);
        exdate.addValue(ex1);
        SingleDates exdateRule = new SingleDates(exdate, duration);
        subRules.add(exdateRule);

        RecurrenceRule recurrence = new RecurrenceRule(dtStart, duration, null, addRules, subRules);
        recurrence.addException(modify1);
        recurrence.addException(cancel1);

        // Get all instances between 2009/01/01 and 2010/01/01.
        Calendar startCal = new GregorianCalendar(pacific);
        startCal.clear();
        startCal.set(2009, Calendar.JANUARY, 1, 0, 0, 0);
        Calendar endCal = (Calendar) startCal.clone();
        endCal.add(Calendar.YEAR, 1);
//        List<Instance> instances = recurrence.expandInstances(-1, startCal.getTimeInMillis(), endCal.getTimeInMillis());
        List<Instance> instances = recurrence.expandInstances(-1, startCal.getTimeInMillis(), Long.MAX_VALUE);
        for (Instance inst : instances) {
            System.out.println(inst);
        }
        System.out.println("Got " + instances.size() + " instances");
    }
}
