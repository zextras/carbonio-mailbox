package com.zimbra.cs.smime;

import com.zimbra.common.localconfig.LC;
import com.zimbra.common.soap.Element;
import com.zimbra.common.soap.SignatureConstants;
import com.zimbra.common.soap.SoapProtocol;
import com.zimbra.common.util.Log;
import com.zimbra.common.util.ZimbraLog;
import com.zimbra.cs.account.Account;
import com.zimbra.cs.account.Provisioning;
import com.zimbra.cs.mailbox.Mailbox;
import com.zimbra.cs.mailbox.Message;
import com.zimbra.cs.mailbox.OperationContext;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cms.SignerInformation;
import org.bouncycastle.i18n.ErrorBundle;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.mail.smime.SMIMESigned;
import org.bouncycastle.mail.smime.validator.SignedMailValidator;
import org.bouncycastle.mail.smime.validator.SignedMailValidatorException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.security.auth.x500.X500Principal;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.security.cert.CertPath;
import java.security.cert.CertPathValidator;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.PKIXParameters;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;

/**
 * This class is responsible for handling S/MIME messages.
 */
public class SmimeHandlerImpl extends SmimeHandler {

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    private static final int CACHE_TIMEOUT_MILLIS = 600000;
    private static final Log LOG = ZimbraLog.smime;
    private static final String RESOURCE_NAME = "org.bouncycastle.mail.smime.validator.SignedMailValidatorMessages";
    private static final Lock LOCK = new ReentrantLock();
    private static long trustStoreRefreshTime = 0L;
    private static KeyStore trustStore = null;

    /**
     *
     * Verify the signature of the message
     * <pre>
     * {
     * "signature":
     *   [
     *      {
     *      "type": "S/MIME",
     *      "valid": false,
     *      "message": "issuer is not trusted",
     *      "messageCode": "UNTRUSTED",
     *      "certificate":
     *      {
     *             "email": "email@xx.com",
     *             "notBefore": 12321312312,
     *             "notAfter": 12321231,
     *             "issuer":
     *             {
     *                  "trusted": false,
     *                  "name": "Actalis"
     *             }
     *      }
     *      }
     *   ]
     * } <br>
     * </pre>
     *
     *           public key: RSA public key: generated by the private key <br>
     *           private key: generated by you. You should not share with any other person <br>
     *           certificate not exactly but like signed public key certificate is created from public key <br>
     *           Signer certificate email sender certificate issuer  <br>
     *           issuer: Authorities of the certificate These issuers create Certificates by issuer private key. <br>
     *                  this means signed certificate is valid. only check validity date is enough. <br>
     */
    @Override
    public boolean verifyMessageSignature(Message msg, Element element, MimeMessage mimeMessage, OperationContext octxt) {

        Element signatureElement = null;
        try {
            if (!Provisioning.getInstance().getLocalServer().isCarbonioSMIMESignatureVerificationEnabled()) {
                return false;
            }

            if (mimeMessage.isMimeType("multipart/signed")) {
                // Extract and validate the signature
                MimeMultipart content = (MimeMultipart) mimeMessage.getContent();

                SMIMESigned signed = new SMIMESigned(content);
                Element dummy = element.addNonUniqueElement(SignatureConstants.SIGNATURE);
                signatureElement = element.addNonUniqueElement(SignatureConstants.SIGNATURE);
                signatureElement.addAttribute(SignatureConstants.TYPE, SignatureConstants.SMIME);
                dummy.detach();
                Element signerCert = signatureElement.addUniqueElement(SignatureConstants.CERTIFICATE);
                Element issuerElement = signerCert.addUniqueElement(SignatureConstants.ISSUER);
                // Get the certificates from the signed email
                List<X509Certificate> certList = getX509Certificates(signed);

                // Set up the PKIX parameters with the trust anchors (trusted root certificates)
                PKIXParameters pkixParams = new PKIXParameters(getKeyStore());
                pkixParams.setRevocationEnabled(false);  // Set this to true if you want to check for CRLs or OCSP

                return validateIssuer(msg, pkixParams, issuerElement, signatureElement, certList, signerCert)
                        && validateSignature(mimeMessage,pkixParams,certList, signatureElement, signerCert, issuerElement);
            }

        } catch (Exception e) {
            LOG.error(e);
            if (signatureElement != null) {
                signatureElement.addAttribute(SignatureConstants.MESSAGE, e.getMessage());
                signatureElement.addAttribute(SignatureConstants.MESSAGE_CODE,
                        SignatureConstants.MESSAGE_CODE_ENUM.ERROR.toString());
            }
        }

        if (signatureElement != null) {
            signatureElement.addAttribute(SignatureConstants.VALID, false);
        }
        return false;
    }

    private boolean validateIssuer(Message msg, PKIXParameters pkixParams, Element issuerElement, Element signatureElement,
                                   List<X509Certificate> certList, Element signerCert)
            throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, CertificateException {
        CertPath certPath = CertificateFactory.getInstance(SignatureConstants.X_509, new BouncyCastleProvider())
                .generateCertPath(certList);
        CertPathValidator certPathValidator = CertPathValidator.getInstance(SignatureConstants.PKIX);

        // Validate the certificate chain (CertPath)
        try {
            certPathValidator.validate(certPath, pkixParams);
            issuerElement.addAttribute(SignatureConstants.TRUSTED, true);
            return true;
        } catch (CertPathValidatorException e) {
            issuerElement.addAttribute(SignatureConstants.TRUSTED, false);
            signatureElement.addAttribute(SignatureConstants.MESSAGE, "issuer is not trusted. Detail: " + e.getMessage());
            signatureElement.addAttribute(SignatureConstants.MESSAGE_CODE, SignatureConstants.MESSAGE_CODE_ENUM.UNTRUSTED.toString());
            certList.stream()
                    .filter(certificate -> msg.getSender().equals(extractCN(certificate.getSubjectX500Principal())))
                    .findFirst()
                    .ifPresent(certificate -> setCertDetails(certificate, signerCert, issuerElement));
            LOG.warn("Smime Authority certificate is not valid: " + e.getMessage());
            return false;
        }

    }

    private boolean validateSignature(MimeMessage mimeMessage, PKIXParameters pkixParams, List<X509Certificate> certList,
                                      Element signatureElement, Element signerCert, Element issuerElement)
            throws SignedMailValidatorException {
        SignedMailValidator validator = new SignedMailValidator(mimeMessage, pkixParams);

        for (SignerInformation signer : validator.getSignerInformationStore().getSigners()) {
            certList.stream()
                    .filter(certificate -> signer.getSID().getSerialNumber().equals(certificate.getSerialNumber()))
                    .findFirst()
                    .ifPresent(certificate -> setCertDetails(certificate, signerCert, issuerElement));

            SignedMailValidator.ValidationResult validationResult = validator.getValidationResult(signer);
            if (validationResult.isValidSignature()) {
                signatureElement.addAttribute(SignatureConstants.MESSAGE, SignatureConstants.VALID);
                signatureElement.addAttribute(SignatureConstants.MESSAGE_CODE,
                        SignatureConstants.MESSAGE_CODE_ENUM.VALID.toString());
                LOG.debug("valid");
            } else {
                ErrorBundle errMsg = new ErrorBundle(RESOURCE_NAME, "SignedMailValidator.sigInvalid");
                errMsg.setClassLoader(SignedMailValidator.class.getClassLoader());
                String error = errMsg.getText(Locale.ENGLISH);
                LOG.error(error);
                // print errors
                for (Object o : validationResult.getErrors()) {
                    ErrorBundle errorMsg = (ErrorBundle) o;
                    LOG.error(errorMsg.getDetail(Locale.ENGLISH));
                    signatureElement.addAttribute(SignatureConstants.MESSAGE, error + " " + errorMsg.getDetail(Locale.ENGLISH));
                    signatureElement.addAttribute(SignatureConstants.MESSAGE_CODE,
                            SignatureConstants.MESSAGE_CODE_ENUM.INVALID.toString());

                    signatureElement.addAttribute(SignatureConstants.VALID, false);
                    return false;
                }
            }
            signatureElement.addAttribute(SignatureConstants.VALID, true);
            signatureElement.addAttribute(SignatureConstants.MESSAGE, SignatureConstants.VALID);
            signatureElement.addAttribute(SignatureConstants.MESSAGE_CODE,
                    SignatureConstants.MESSAGE_CODE_ENUM.VALID.toString());
            return true;
        }
        return true;
    }

    private void setCertDetails(X509Certificate certificate, Element signerCert, Element issuerElement) {
        signerCert.addAttribute(SignatureConstants.EMAIL, extractCN(certificate.getSubjectX500Principal()));
        signerCert.addAttribute(SignatureConstants.NOT_BEFORE, certificate.getNotBefore().getTime());
        signerCert.addAttribute(SignatureConstants.NOT_AFTER, certificate.getNotAfter().getTime());
        issuerElement.addAttribute(SignatureConstants.NAME, extractCN(certificate.getIssuerX500Principal()));
    }

    static List<X509Certificate> getX509Certificates(SMIMESigned signed) throws CertificateException {
        Collection<X509CertificateHolder> certHolders = signed.getCertificates().getMatches(null);
        List<X509Certificate> certList = new ArrayList<>();
        JcaX509CertificateConverter jcaX509CertificateConverter = new JcaX509CertificateConverter().setProvider(new BouncyCastleProvider());
        for (X509CertificateHolder certHolder : certHolders) {
            X509Certificate certificate = jcaX509CertificateConverter.getCertificate(certHolder);
            certList.add(certificate);
        }
        return certList;
    }

    static KeyStore getKeyStore() throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
        if (trustStore == null || (System.currentTimeMillis() - trustStoreRefreshTime > CACHE_TIMEOUT_MILLIS)) {
            LOCK.lock();  // Acquires the lock
            try {
                if (trustStore == null || (System.currentTimeMillis() - trustStoreRefreshTime > CACHE_TIMEOUT_MILLIS)) {
                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                    trustStore.load(new FileInputStream(LC.get(LC.mailboxd_truststore.key())),
                            LC.get(LC.mailboxd_truststore_password.key()).toCharArray());
                    trustStoreRefreshTime = System.currentTimeMillis();
                }
            } finally {
                LOCK.unlock();  // Releases the lock
            }
        }
        return trustStore;
    }

    String extractCN(X500Principal principal) {
        String name = principal.getName();
        String[] parts = name.split(",");
        for (String part : parts) {
            if (part.toUpperCase().startsWith("CN=")) {
                return part.substring(3);
            }
        }
        return "";
    }

    @Override
    public MimeMessage decryptMessage(Mailbox mailbox, MimeMessage mimeMessage, int itemId) {
        return mimeMessage;
    }

    @Override
    public void updateCryptoFlags(Message msg, Element element, MimeMessage originalMimeMessage,
                                  MimeMessage decryptedMimeMessage) {
    }

    @Override
    public MimeMessage decodePKCS7Message(Account account, MimeMessage pkcs7MimeMessage) {
        return null;
    }

    @Override
    public void addPKCS7SignedMessageSignatureDetails(Account account, Element m, MimeMessage mm,
                                                      SoapProtocol mResponseProtocol) {
    }

    @Override
    public void encodeCertificate(Account account, Element elem, String certData, SoapProtocol mResponseProtocol,
                                  List<String> emailAddresses) {
    }
}
